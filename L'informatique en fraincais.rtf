{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}{\f2\fnil\fcharset238 Calibri;}{\f3\fnil\fcharset2 Wingdings;}{\f4\fnil\fcharset1 Cambria Math;}{\f5\fnil\fcharset0 Cambria Math;}{\f6\fnil\fcharset238 Cambria Math;}{\f7\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;\red0\green255\blue0;\red0\green255\blue255;}
{\*\generator Riched20 10.0.19041}{\*\mmathPr\mmathFont4\mwrapIndent1440 }\viewkind4\uc1 
\pard\sa200\sl276\slmult1 {\f0\fs22\lang9{\field{\*\fldinst{HYPERLINK https://www.apprendre-en-ligne.net/info/ }}{\fldrslt{https://www.apprendre-en-ligne.net/info/\ul0\cf0}}}}\f0\fs22\lang1033\par
apprendre les bases de l'informatique, en Francais. \par
\highlight2 Chapitre 1: L'histoire\highlight0\par
un ordinateure est:\par

\pard{\pntext\f7\'B7\tab}{\*\pn\pnlvlblt\pnf7\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 electonique\par
{\pntext\f7\'B7\tab}numeric\par
{\pntext\f7\'B7\tab}programmable\par
{\pntext\f7\'B7\tab}peux executer des operations elementaire\par
{\pntext\f7\'B7\tab}peux enregistrer un programme en memoire, et l'exicuter\par
{\pntext\f7\'B7\tab}?a ete construite, n'est pas que theorique\par

\pard\sa200\sl276\slmult1 la premiere generation commence en 1936 avec circuits \'e9lectroniques, tubes \'e0 vide, condensateurs et relais.\par
\highlight2 Chapitre 2: Comment Ca Marche\highlight0\par
\highlight3 2.1 Fonctionement General d'un ordinateur\highlight0\par
analogue a une etre vivant, avec Organe d'entr\'e9e + Organe de traitement de l'information + Organe de sortie\par
human: 5 sens + cerveaux + muscles\par
ordinateur: sourie/clavier + + ecrant/imprimante/haut-parleure/etc \par
4 partie de l'Architecture de von Neumann:\par

\pard\li720\sa200\sl276\slmult1 1. unite d'arithm\'e9tique et logique (UAL) (aka traitement). effectue les operations elementaire + logic + comparatif\par
2.L'unit\'e9 de contr\'f4le (UC). coordonation des autres 3. prend ces directions de la memoire + ordone UAL\par
3. La m\'e9moire. vive (pour le functionment actif) + permanente (pour le rangement). contient les donner et les programmes\par
4. Les entr\'e9es-sorties. (clavier + sourie + \'e9cran + imprimantes + etc\par

\pard\sa200\sl276\slmult1 bus = ensemble de liasons physique (e.g. cable) \par
\par
\highlight3 2.2. \'c0 l'int\'e9rieur d'un ordinateur\highlight0\par
2.2.1. carte m\'e8re (motherboard)  le \'ab cerveau \'bb/system nerveux de l'ordinateur : le processeur. composants et p\'e9riph\'e9riques se branchent directement sur.  circuit imprim\'e9 servant \'e0 interconnecter toutes les composantes d'un micro-ordinateur. \par
2.2.2. Branchement: clavier, souris, ecrent, imprimante, reseau, haut-parleur, micro, etc. maintenent: USB pour toute saufe l'alimentation.\par
alimentation : fournit une tension transform\'e9e et adaptee\par
lecteurs / graveurs : lire/ecrire un CD-ROM ou un DVD-ROM. \par
disque dur : la \'ab m\'e9moire \'bb enregistre les donn\'e9es. 1+ par ordinateure, chaque avec partitions.\par
La carte son : Parfois int\'e9gr\'e9e \'e0 la carte m\'e8re. se branche sur la carte m\'e8re sur un port PCI.\par
La carte graphique : affichage sur l'\'e9cran\par
\par
\highlight3 2.3 la m\'e9moire \highlight0 = composant \'e9lectronique capable de stocker temporairement des donn\'e9es\par
m\'e9moire centrale = m\'e9moire interne = m\'e9moire vive = m\'e9morise temporairement les donn\'e9es lors de l'ex\'e9cution des programmes.\par
m\'e9moire de masse = m\'e9moire physique = m\'e9moire externe = stocke des informations \'e0 long terme e.g. disque dur + CDROM + DVD-ROM + m\'e9moires mortes.\par
principales caract\'e9ristiques technique d'une m\'e9moire:\par

\pard\li720\sa200\sl276\slmult1\f1\bullet  la capacit\f0\'e9 = volume global d'informations (en bits) que la m\'e9moire peut stocker\par
\f1\bullet  le temps d'acc\f0\'e8s = l'intervalle de temps entre la demande de lecture/\'e9criture et la disponibilit\'e9 de la donn\'e9e \par
\f1\bullet  le temps de cycle\f0\lang4105  =\lang1033  l'intervalle de temps minimum entre deux acc\'e8s successifs\par
\f1\bullet  le d\f0\'e9bit = volume d'information \'e9chang\'e9 par unit\'e9 de temps, exprim\'e9 en bits par seconde\par
\f1\bullet  la non-volatilit\f0\'e9 = aptitude \'e0 conserver les donn\'e9es lorsqu'elle n'est plus aliment\'e9e \'e9lectriquement\par

\pard\sa200\sl276\slmult1 M\'e9moire vive = RAM = Random Access Memory = m\'e9moire principale du syst\'e8me = stocke temporairement des donn\'e9es lors de l'ex\'e9cution d'un programme. est volatile\par
M\'e9moire morte = ROM = Read Only Memory=  non-volatile. peut \'eatre acc\'e9d\'e9e qu'en lecture.\par
M\'e9moire flash = compromis entre les m\'e9moires vive et morte. non-volatile + accessible en lecture ou en \'e9criture + temps d'acc\'e8s elever\par
m\'e9moire cache = acc\'e9l\'e8re le fonctionnement de l'ordinateur = stock les donn\'e9es utilis\'e9es le plus r\'e9cemment pour re-utiliser. rapide . \line m\'e9moire cache interne = \'e0 l'int\'e9rieur du processeur \line m\'e9moire cache externe = \'e0 l'ext\'e9rieur du processeur \par
\highlight3 2.4. Le BIOS\highlight0  = Basic Input/Output System = interface entre syst\'e8me d'exploitation et carte m\'e8re. stock\'e9 dans une ROM.\par
Lorsque le syst\'e8me/CPU est mis sous-tension ou r\'e9amorc\'e9(Reset), e BIOS va:\par
\f1\bullet  faire le test du CPU\par
\bullet  v\f0\'e9rifier le BIOS\par
\f1\bullet  initialiser le timer (l'horloge interne)\par
\bullet  v\f0\'e9rifier la m\'e9moire vive et la m\'e9moire cache\par
\f1\bullet  v\f0\'e9rifier toutes les configurations (clavier, disquettes, disques durs ...)\par
\highlight3 2.5. Le syst\'e8me d'exploitation\highlight0\par
syst\'e8me d'exploitation =SE = operating system = OS = assure la liaison entre les ressources mat\'e9rielles + l'utilisateur + les applications\par
SE utilise un pilote pour chaque p\'e9riph\'e9rique\par
r\'f4les du syst\'e8me d'exploitation:\par
\f1\bullet  Gestion du processeur : \f0\lang4105 SE \lang1033 g\'e9re l'allocation du processeur entre les diff\'e9rents programmes \par
\f1\bullet  Gestion de la m\f0\'e9moire vive : SE g\'e9re l'espace m\'e9moire allou\'e9 \'e0 chaque application + usager\par
peut cr\'e9er une zone m\'e9moire sur le disque dur = m\'e9moire virtuelle = permet de faire fonctionner (lentement) des applications n\'e9cessitant plus de m\'e9moire qu'il n'y a de m\'e9moire vive disponible \par
\f1\bullet  Gestion des entr\f0\'e9es/sorties : SE unifie et de contr\'f4le l'acc\'e8s des programmes aux ressources mat\'e9rielles par via des pilotes \par
\f1\bullet  Gestion de l'ex\f0\'e9cution des applications : SEex\'e9cute des applications en leur affectant les ressources n\'e9cessaires \'e0 leur bon fonctionnement, juste qua rient qui "tue"  l'application \par
\f1\bullet  Gestion des droit\f0\lang4105 : \f1\lang1033  \f0\lang4105 gere \lang1033 s\'e9curit\'e9 la li\'e9e \'e0 d'ex\'e9cution en garantissant que les ressources ne sont utilis\'e9es que par les programmes et utilisateurs poss\'e9dant les droits ad\'e9quats.\par
\f1\bullet  Gestion des fichiers : \f0 g\'e8re la lecture et l'\'e9criture dans le syst\'e8me de fichiers et les droits d'acc\'e8s aux fichiers par les utilisateurs et les applications.\par
\f1\bullet  Gestion des informations : \f0 fournit un certain nombre d'indicateurs permettant de diagnostiquer le bon fonctionnement de la machine.\par
\par
SE est compos\'e9 d'un ensemble de logiciels permettant de g\'e9rer les interactions incluent :\par
\f1\bullet  Le noyau \f0\lang4105 = \f1\lang1033 kernel\f0\lang4105  =\f1\lang1033  \f0 fonctions fondamentales e.g. gestion de m\'e9moire + processus + fichiers + entr\'e9es-sorties principales + fonctionnalit\'e9s de communication.\par
\f1\bullet  L'interpr\f0\'e9teur de commande = shell = coquille = communication entre SE et unitisateure par un langage de commandes\par
\f1\bullet  Le syst\f0\'e8me de fichiers = file system = FS = enregistre les fichiers dans une arborescence. \par
\par
multit\'e2che = multithreaded = plusieurs \'ab t\'e2ches \'bb/\'ab processus \'bb peuvent \'eatre ex\'e9cut\'e9es simultan\'e9ment.\par
processus l\'e9gers  = threads = s\'e9quence d'instructions  \par
syst\'e8me pr\'e9emptif = poss\'e8de un ordonnanceur/planificateur qui r\'e9partit le temps machine entre diff\'e9rents processus \par
syst\'e8me \'e0 temps partag\'e9 = un quota de temps est allou\'e9 \'e0 chaque processus par l'ordonnanceur. \par
multiprocessing = technique consistant \'e0 faire fonctionner plusieurs processeurs en parall\'e8le afin d'obtenir une puissance de calcul plus importante. g\'e9re le partage de la m\'e9moire entre plusieurs processeurs + distribuer la charge de travail. \par
\highlight3 2.6. Le disque dur\highlight0  = conserve les donn\'e9es de mani\'e8re permanente\par
est reli\'e9 \'e0 la carte m\'e8re via un contr\'f4leur de disque dur, qui g\'e8re les disques qui lui sont reli\'e9s + interpr\'e8te les commandes envoy\'e9es par le processeur et les achemine au disque concern\'e9.\par
disque dur externe = connecter par USB\par
disques durs internes = branch\'e9s directement sur la carte m\'e8re\par
Structure =  bo\'eetier herm\'e9tique qui contien une pile de plusieurs disques rigides en m\'e9tal/verre/c\'e9ramique range les donnes sur une couche magn\'e9tique de quelques microns d'\'e9paisseur, recouverte d'un film protecteur. lecture et l'\'e9criture via des t\'eates de lecture avec des \'e9lectroaimants qui se baissent/soul\'e8vent/deplace lateralement pour pouvoir lire ou \'e9crire.  \par
 disques tournent tr\'e8s rapidement autour d'un axe\par
a des millions de bits\par
une seule t\'eate peut lire ou \'e9crire \'e0 un moment donn\'e9.\par
Caract\'e9ristiques techniques:\par
\f1\bullet  Capacit\f0\'e9 = volume de donn\'e9es pouvant \'eatre stock\'e9es sur le disque.\par
\f1\bullet  Taux de transfert\f0\lang4105  =\f1\lang1033  d\f0\'e9bit = quantit\'e9 de donn\'e9es pouvant \'eatre lues/\'e9crites sur le disque,\par
en bits par seconde.\par
\f1\bullet  Vitesse de rotation\f0\lang4105  =\f1\lang1033  \f0 tours par minutes des plateaux, en rpm ~7200-15000 rpm. \par
\f1\bullet  Temps de latence \f0\lang4105 =\f1\lang1033  temps \f0\'e9coul\'e9 entre le moment o\'f9 le disque trouve la piste et le moment\par
o\'f9 il trouve les donn\'e9es.\par
\f1\bullet  Temps d'acc\f0\'e8s moyen = temps moyen que met la t\'eate pour se positionner sur la bonne piste\par
et acc\'e9der \'e0 la donn\'e9e\par
\f1\bullet  Densit\f0\'e9 radiale = nombre de pistes par pouce, en tpi = Track per Inch\par
\f1\bullet  Densit\f0\'e9 lin\'e9aire = nombre de bits par pouce sur une piste donn\'e9e, en bpi = Bit per Inch\par
\f1\bullet  Densit\f0\'e9 surfacique = rapport de la densit\'e9 lin\'e9aire sur la densit\'e9 radiale.\par
\f1\bullet  M\f0\'e9moire cache = m\'e9moire tampon = quantit\'e9 de m\'e9moire embarqu\'e9e sur le disque dur.\par
\f1\bullet  Interface \f0\lang4105 = \f1\lang1033 la connectique du disque dur\par
Formatage\f0\lang4105  =\f1\lang1033  l'action de pr\f0\'e9parer un support de donn\'e9es pour qu'il soit reconnu par le SE.  \line peut rendre impossible l'acc\'e8s aux donn\'e9es pr\'e9c\'e9demment pr\'e9sentes sur le disque.\par
formats diff\'e9rents = FAT, FAT32, NTFS, HFS, ext2, ext3, ext4, UFS, etc\par
partitionnement = diviser un disques de grande capacit\'e9 en partitions logiques\par
formatage \'e0 z\'e9ro = chaque bit de donn\'e9e est remplac\'e9 par un z\'e9ro, et les donn\'e9es sont perdues. \par
\par
\par
Fragmentation = morceaux de fichier eparpilier sur le disque dur\par
quand un fichier est effac\'e9, cela g\'e9n\'e8re un espace vide sur le disque. Les fichiers suivants vont combler les \'ab trous \'bb, et vont donc \'eatre \'e9parpill\'e9s en portions de fichiers sur le disque. lorsque le syst\'e8me acc\'e8de \'e0 un telle fichier, la t\'eate du disque va devoir parcourir l'ensemble des endroits o\'f9 les morceaux du fichier sont enregistr\'e9s pour pouvoir lire celui-ci. --> une baisse de performances.\par
outil de d\'e9fragmentation = logiciel capable qui r\'e9organise les fichiers pour que les parcelles de fichiers soient stock\'e9es de mani\'e8re contigu\'eb \par
\highlight3 2.7. Le disque dur SSD  \highlight0 = solid state drive = utilise des composants \'e9lectroniques (comme une cle USB), non-volatile, fiabilie. \par
probleme= usure des cellule a chaque ecriture (mais lecture illimiter). auto-gere les cellule suruser, mais  capacit\'e9 diminue graduellement\par
\highlight3 2.8. La cl\'e9 USB\highlight0  = petit m\'e9dia amovible qui se branche sinfo et electricite) sur une port USB \par
contient une m\'e9moire flash ou un mini disque dur. \par
insensibles \'e0 la poussi\'e8re et aux rayures\par
relativement standardis\'e9es, cependant certaines n\'e9cessitant l'installation d'un pilote.\par
Dur\'e9e de vie varier: des mois a 10 ans. pas tres fiable.\par
Performances d\'e9pendent beaucoup du mod\'e8le\par
\highlight3 2.9. L'int\'e9rieur d'un smartphone\highlight0\par
syst\'e8me sur une puce = system on a chip = SoC = est le composant central d'un smartphone = processeur + processeur graphique + un modem LTE + processeur d'affichage + processeur vid\'e9o + autres \par
batterie(s) lithium-ion\par
M\'e9moire et stockage = RAM + m\'e9moire flash\par
Modems pour recevoir + envoyer des SMS + appels\par
Cam\'e9ras arri\'e8re et avant. chaque camera comprend trois parties principales : capteur (qui d\'e9tecte la lumi\'e8re) + l\f1 a lentille (le composant dans lequel passe la lumi\f0\'e8re)  + \f1 processeur d'image.\par
\f0\'e9crans tactiles = surface solide de type verre parcourue d'une grille \'e9lectriquement charg\'e9e et presque invisible \'e0 l'\f2\u339?il nu. L'accumulation de\f0\lang4105  \f2\lang1033 charges \f0\'e9lectriques sur la plaque de verre lors du contact des doigts de l'utilisateur transf\'e8re une partie de ces charges dans les doigts, ce qui provoque un d\'e9ficit qu'il suffit ensuite de localiser, pour traiter l'information, via un algorithme de calcul int\'e9gr\'e9 directement dans le p\'e9riph\'e9rique, qui  d\'e9termine le(s) point(s) d'impact + sens du mouvement + pression exerc\'e9e, et agit en cons\'e9quence.\par
\highlight2 Chapitre 3 Codage de l'information\highlight0\par
\highlight3 3.1. Vocabulaire\highlight0\par
bit = b = Binary digIT = un 0 ou un 1 = la plus petite unit\'e9 d'information \par
octet = B = byte = 8 bits\par
mot = word = 16 bits  \par
mot double = double word = dword = 32 bits\par
\highlight3 3.2. Les bases d\'e9cimale, binaire et hexad\'e9cimale\par
\highlight0 syst\'e8me positionnel = l'endroit o\'f9 se trouve le symbole d\'e9finit sa valeur. \par
d\'e9cimal = base 10\par
 binaire = base 2\par
hexad\'e9cimal = base 16\par
\highlight3 3.3. Repr\'e9sentation des nombres entiers\par
\highlight0 3.3.1. Repr\'e9sentation d'un entier naturel\par
entier naturel = entier positif ou nul. \par
un codage sur n permet de repr\'e9senter des nombres entiers naturels compris 0 et (2^n)- 1.\par
3.3.2. Repr\'e9sentation d'un entier relatif\par
entier relatif = entier pouvant \'eatre positif, nul, ou n\'e9gatif\par
compl\'e9ment \'e0 deux = repr\'e9sentation\par
bit de poids fort = le bit situ\'e9 \'e0 l'extr\'eame gauche = represente le signe. 0 pour positif ou nul, 1 pour negatif\par
le plus grand entier relatif positif cod\'e9 sur n bits sera (2^(n-1))-1.\par
\highlight3\f1 3.4. Repr\f0\'e9sentation des nombres r\'e9els\highlight0\par
Attention ! Un nombre \'e0 d\'e9veloppement d\'e9cimal fini en base 10 ne l'est pas forc\'e9ment en base 2.\par
Cela peut engendrer de mauvaises surprises. \par
e.g. on n'arrive pas \'e0 repr\'e9senter exactement 0.3 en binaire\par
3.4.2. La norme IEEE 754 = d\'e9finit la fa\'e7on de coder un nombre r\'e9el. \par
utilise 32 bits + d\'e9finit trois composantes :\par

\pard\li720\sa200\sl276\slmult1\f1\bullet  le signe \f0\lang4105 = \lang1033 un bit, le bit de poids fort \par
\f1\bullet  l'exposant \f0\lang4105 = \lang1033 8 bits cons\'e9cutifs au signe \par
\f1\bullet  la mantisse\f0\lang4105  = \f1\lang1033  bits situ\f0\'e9s apr\'e8s la virgule = 23 bits \par

\pard\sa200\sl276\slmult1 l'exposant 00000000 est pour \'e9crire le nombre 0 uniquement\par
\f1 l'exposant 11111111 signaler des erreurs\f0\lang4105  =\f1\lang1033  NaN\f0\lang4105  = \lang1033 Not a number \par
\f1 il faut ajouter \f0\'e0 l'exposant un biais, fix\'e9 \'e0 27-1 = 127 (01111111)\par
Il y a deux 0 : un n\'e9gatif (1 suivi de 31 z\'e9ros) et un positif (32 z\'e9ros)\par
\highlight3 3.5. Le code ASCII \highlight0 = American Standard Code for Information Interchange\par
correspondance entre 7 bits binaires et les caract\'e8res de l'alphabet latin + symboles + signes + chiffres\par
permet au machines de stocker+analyser+communiquer de l'information textuelle.\par
\f1\bullet  Les codes 0 \f0\'e0 31 = caract\'e8res de contr\'f4le, inclue: \f1 retour \f0\'e0 la ligne (Carriage return) ; \f1 bip sonore (Audible bell)\f0\lang4105 , etc\f1\lang1033\par
\bullet  Les codes 65 \f0\'e0 90 = majuscules.\par
\f1\bullet  Les codes 97 \f0\'e0 122  = minuscules \par
code ASCII \'e9tendu = ISO-8859  = 8 bits, inclue accents\par
Unicode = normal aternative =  d\'e9finit des dizaines de milliers de codes, les 128 premiers restent compatibles avec ASCII.\par
UTF-8 = Universal Character Setm Transformation Format 1 - 8 bits = \'ab r\'e9pertoire universel de caract\'e8res cod\'e9s \'bb " = totalement compatible avec Unicode et  ASCII = le plus utilis\'e9 \par
\highlight3 3.6. Codes d\'e9tecteurs/correcteurs d'erreurs\par
\highlight0 code correcteur = utilise la redondance pour corriger les erreurs de transmission d'un message \par
Comment d\'e9tecter et/ou corriger des erreurs ?\par
On peut transmettre un nombre soit en chiffres, soit en lettres :\par
si on envoie \'ab 0324614103 \'bb = erreure pas detectable, plus concise\par
si on envois \'ab z\'e9ro trente-deux quatre cent soixante et un quarante et un z\'e9ro trois \'bb. = facile de detecter et corriger les erreures, pas concise\par
canaux de transmission imparfaits -> erreurs lors des \'e9changes. \f1 probabilit\f0\'e9 d'erreur sur une ligne t\'e9l\'e9phonique est de 10^7\par
Principe g\'e9n\'e9ral = \f1 Chaque suite de\f0\lang4105  k \f1\lang1033  bits \f0\'e0 transmettre est augment\'e9e par une autre suite de r bits de redondance/contr\'f4le.-> \f1 on utilise un code\f0\lang4105  \f1\lang1033 C(n, k) avec n = k + r \par
3.6.1. La distance de Hamming\f0\lang4105  = \lang1033 compte le nombre de bits alt\'e9r\'e9s dans la transmission d'un message d'une longueur donn\'e9e.\par
e.g. : la distance de Hamming entre 1011101 et 1001001 est 2 car deux bits sont diff\'e9rents.\par
3.6.2. Somme de contr\'f4le = checksum = d\'e9tecter les erreurs, mais pas les corriger. = d'ajouter aux donn\'e9es des \'e9l\'e9ments simple a calculer et d\'e9pendant des donnees \par
Bit de parit\'e9 = \'e9tant \'e9gal \'e0 z\'e9ro si la somme des autres bits est paire et \'e0 un  si impaire = permet de d\'e9tecter un nombre impairs d'erreurs, mais pas un nombre pair \par
3.6.3. Le code ISBN = International Standard Book Number =  num\'e9ro international qui identifier  chaque livre unique publi\'e9. pour simplifier la gestion informatique des \par
num\'e9ro ISBN-10= quatre segments total de 10 chiffres = segments ABC de longueur variable + segment D de longueur fixe\par

\pard\li720\sa200\sl276\slmult1\f1\bullet  A \f0\lang4105 = \f1\lang1033 groupe de codes pour un pays\f0\lang4105  / \f1\lang1033 zone g\f0\'e9ographique / zone de langue.\par
\f1\bullet  B \f0\lang4105 =\f1\lang1033  l'\f0\'e9diteur de la publication.\par
\f1\bullet  C \f0\lang4105 = \f1\lang1033 num\f0\'e9ro d'ordre de l'ouvrage chez l'\'e9diteur.\par
\f1\bullet  D \f0\lang4105 = \f1\lang1033 chiffre-cl\f0\'e9 de verification calcul\'e9 \'e0 partir des chiffres pr\'e9c\'e9dents\par

\pard\sa200\sl276\slmult1 3.6.4. Formule de Luhn = algorithme \'ab modulo 10 \'bb = formule de somme de contr\'f4le, utilis\'e9e pour valider une vari\'e9t\'e9 de num\'e9ros de comptes + l'immatriculation du mat\'e9riel ferroviaire =prend in  un num\'e9ro d'identit\'e9 partiel +  g\'e9n\'e8re un chiffre de v\'e9rification -> identifiant complet.\par
3.6.5. V\'e9rification des CCP = Compte Courant Postal\par
3.6.6. Code de Hamming\line permet la d\'e9tection et la correction automatique d'une d'un bit du message. \par
code parfait = il n'existe pas d'autre code plus compact ayant la m\'eame capacit\'e9 de correction. \line aka rendement maximal.\par
Structure d'un code de Hamming\par

\pard\li720\sa200\sl276\slmult1\f1\bullet  les m bits du message \f0\'e0 transmettre et les n bits de contr\'f4le de parit\'e9.\par
\f1\bullet  longueur totale : 2\f0\lang4105 ^\f1\lang1033 n - 1\par
\bullet  longueur du message : m = (2\f0\lang4105 ^\f1\lang1033 n - 1) - n\par
\bullet  on parle de code x-y : \par

\pard\li1440\sa200\sl276\slmult1 x\f0\lang4105  =\f1\lang1033  la longueur totale du code (n+m) \par
y \f0\lang4105 =\f1\lang1033  longueur du message\f0\lang4105  \f1\lang1033 (m)\par

\pard\li720\sa200\sl276\slmult1\bullet  les bits de contr\f0\'f4le de parit\'e9 Ci sont en position 2i (pour i = 0, 1, 2, ...)\par
\f1\bullet  les bits du message Dj occupe le reste du message. \f0\par

\pard\sa200\sl276\slmult1 Retrouver l'erreur dans un mot de Hamming\par
Si les bits de contr\'f4le de parit\'e9 C2, C1, C0 ont tous la bonne valeur, il n'y a pas d'erreur ; \line sinon la valeur des bits de contr\'f4le indique la position de l'erreur entre\par
\highlight3 3.7. Codage de Huffman\highlight0  = m\'e9thode de compression statistique de donn\'e9es qui r\'e9duie la longueur du codage d'un alphabet en calculant les fr\'e9quences des caract\'e8res du, puis on va construire un arbre binaire dont les extr\'e9mit\'e9s seront les lettres. \par
Les lettres les plus fr\'e9quentes en haut de l'arbre, les moins fr\'e9quentes en bas. \par
recode les donn\'e9es a occurrence faible a une longueur binaire sup\'e9rieure \'e0 la moyenne, et les donn\'e9es fr\'e9quentes sur une longueur binaire courte.\par
Au d\'e9part, chaque lettre a une \'e9tiquette correspondant \'e0 sa fr\'e9quence d'apparition. Il y a autant d'arbres (\'e0 1 sommet) que de lettres.\par
L'algorithme choisit \'e0 chaque \'e9tape les deux arbres d'\'e9tiquettes minimales, x et y, et les remplace par l'arbre form\'e9 de x et y et ayant comme \'e9tiquette la somme de l'\'e9tiquette de x et de l'\'e9tiquette de y. \par
Ce principe de compression est aussi utilis\'e9 dans le codage d'image TIFF (Tagged Image Format\par
File) et JPEG (Join Photographic Experts Group) \par
ancienne m\'e9thode qui a encore des performances appr\'e9ciables.\par
\highlight3 3.8. Codes-barres = \highlight0 repr\'e9sentation d'une donn\'e9e alphanum\'e9rique = symbole constitu\'e9 de barres et d'espaces dont l'\'e9paisseur varie en fonction de la donnee. destin\'e9s \'e0 lakjnm  lecture automatis\'e9e par un capteur \'e9lectronique.\par
3.8.1. Codes-barres EAN = European Article Numbering = identifie des articles de fa\'e7on unique\par
\f1\bullet  les codes EAN-8 sont r\f0\'e9serv\'e9s \'e0 l'usage sur des produits de petite taille \par
\f1\bullet  les codes EAN-13 sont utilis\f0\'e9s sur tous les autres produits.\par
utilise des notions d'arithm\'e9tique modulaire. \par
Structure du code EAN-13\par

\pard\li720\sa200\sl276\slmult1\f1\bullet  Le caract\f0\'e8re de D\'e9but cod\'e9 101 (1 = noir, 0 = blanc)\par
\f1\bullet  Le second caract\f0\'e8re du Pr\'e9fixe (6). Le premier caract\'e8re du pr\'e9fixe n'est pas cod\'e9.\par
\f1\bullet  Les cinq caract\f0\'e8res du Num\'e9ro de Participant (12345)\par
\f1\bullet  Le S\f0\'e9parateur Central est cod\'e9 01010\par
\f1\bullet  Les cinq caract\f0\'e8res du Num\'e9ro d'Article (67890)\par
\f1\bullet  Le Check Digit (0)\par
\bullet  Le caract\f0\'e8re de Fin cod\'e9 101.\par

\pard\sa200\sl276\slmult1 3.8.2. Codes QR = code-barres en deux dimensions = code \'e0 matrice = constitu\'e9 de modules noirs dispos\'e9s dans un carr\'e9 \'e0 fond blanc. standard ISO (IEC18004)\par
7089 caract\'e8res num\'e9riques, ou 4296 caract\'e8res alphanum\'e9riques, ou 2953 octets\par

\pard\sa200\sl276\slmult1\qc\highlight2 Chapitre 4 Traitement d'images\highlight0\par

\pard\sa200\sl276\slmult1\highlight3 4.1. Codage des couleurs\highlight0\par
4.1.1. Le syst\'e8me RVB = Red Green Blue = pour la lumi\'e8re (\'e9cran, projecteurs, ...)\par
dans les formats d'image JPEG et TIFF.\par
utilise les couleurs primaires en synth\'e8se additive ~ les trois longueurs d'ondes auxquelles r\'e9pondent les trois types de c\'f4nes de l'\f2\u339?il humain\par
\f0 triplet \{composante rouge, composante verte, composante bleue\}\par
\{255, 255, 255\} = blanc\line\{255, 0, 0\} = un rouge pur\line\{100, 100, 100\} = gris\par
4.1.2. Le cube des couleurs =repr\'e9sentation des couleurs RVB = un rep\'e8re orthonorm\'e9 dont les trois axes r, g, b repr\'e9sentent les intensit\'e9s de rouge, de vert et de bleu. \par
4.1.3. Le syst\'e8me CMJN (cyan, magenta, jaune, noir ) = quadrichromie = CMYK (cyan, magenta, yellow, key) = proc\'e9d\'e9 d'imprimerie \'e0 partir des trois teintes de base + noir \par
\highlight3 4.2. Formats d'images\highlight0\par
image num\'e9rique = image acquise, cr\'e9\'e9e, trait\'e9e ou stock\'e9e sous forme binaire \par
4.2.1. Images matricielles = bitmap = matrice (tableau) de points (pixels) color\'e9s.\par
adapte bien \'e0 l'affichage sur \'e9cran informatique ; peu adapt\'e9 pour l'impression\par
e.g.  jpeg, gif, png, tiff, bmp\par
d\'e9finition d'une image matricielle = nombre de points la composant souvent donne en vertical x horizontal (e.g. 200px x 450px) non en total (e.g. 90000)\par
r\'e9solution d'une image matricielle = nombre de pixels par unit\'e9 de longueur (classiquement en ppp)\par
4.2.2. Images vectorielles = repr\'e9sente les donn\'e9es de l'image par des formules g\'e9om\'e9triques\par
 e.g. \'ab une droite trac\'e9e entre les points (x1, y1) et (x2, y2) \'bb, puis \'ab un cercle trac\'e9 de centre (x3, y3) et de rayon 30 de couleur rouge \'bb. \par
permet d'agrandir ind\'e9finiment sans perdre la qualit\'e9 initiale + faible encombrement.\par
e.g ai (Adobe Illustrator), eps (encapsulated postscript), pdf , svg (scalable vector graphics), swf (flash).\par
\highlight3 4.3. Courbe tonale\highlight0\par
Retoucher une image = modifier les valeurs de certains pixels.\par
 localement ou globalement. \par
courbe tonale = outil pour modification global. une pour chaque couleur RVB\par
augmenter/diminuer la luminosit\'e9 = ajouter/soustraire une valeur fixe \'e0 tous les niveaux.\line possible perte d'informations si le changement irais en bas de 0 ou en haut de 255\par
augmenter le contraste =assombrir les points fonc\'e9s + \'e9claircir les points clairs\par
\highlight3 4.4. Quelques traitements classiques\par
\highlight0 4.4.1. N\'e9gatif = toutes les composantes x de tous les pixels de l'image sont remplac\'e9es par 255-x.\par
4.4.2. Rouge = assignant la valeur 0 aux composantes verte et bleue\par
(similairement pour le traiment vert et le traimement bleu)\par
4.4.3. Niveaux de gris = les trois composantes ont la "m\'eame" valeur.\par
L'\f2\u339?il est plus sensible \f0\'e0 certaines couleurs, pour tenir compte de cette sensibilit\'e9, la formule standard donnant le niveau de gris est : gris = int(round(0.299\'b7rouge + 0.587\'b7vert + 0.114\'b7bleu))\par
4.4.4. Seuillage = m\'e9thode la plus simple de segmentation d'image\par
pour une image en niveau de gris = le seuillage d'image peut cr\'e9er une image comportant uniquement deux valeurs, noir ou blanc. \line remplace un \'e0 un les pixels d'une image par rapport \'e0 une valeur seuil fix\'e9e.\line si un pixel \'e0 valeur > au seuil -> valeur = 255 (blanc), et  si valeur < au seuil -> valeur = 0 (noir)\par
Avec une image en couleur, on fera de m\'eame avec les trois composantes rouge, vert et bleu. \par
possible avec huit couleurs: blanc, noir, rouge, vert, bleu, magenta, jaune et cyan.\par
4.4.5. S\'e9pia = qualit\'e9 de tirage "niveaux de brun"\par
la couleur s\'e9pia dans le syst\'e8me RVB = S(94, 38, 18)\par
la transformation d'une image couleur en une image en nuances de est fait en deux temps. \line 1. seuillage au noir/blank ou niveau de gris\line 2. remplacement au spectrum sepia\par
4.4.6. Pixellisation\par
L'image est divis\'e9e en rectangles de la taille sp\'e9cifi\'e9e \line Chaque rectangle est ensuite rempli avec la couleur moyenne de la zone.\par
\highlight3 4.5. Les drapeaux\highlight0\par
permet de metre les coleurs d'un drapeux par desu une image\par
\highlight3 4.6. Filtrage\highlight0  = modifier la valeur des pixels d'une image = cr\'e9er une nouvelle image en se servant des valeurs des pixels de l'image d'origine.\par
filtre = transformation math\'e9matique = produit de convolution = permet de modifier la valeur d'un pixel en fonction des valeurs des pixels avoisinants, affect\'e9es de coefficients = repr\'e9sent\'e9 par une matrice \par
4.6.1. Lissage = rend l'image plus floue = un filtre passe-bas = renplace la valeur de chaque pixel par la moyenne des 9 pixels autour\par
4.6.2. Accentuation = rend l'image plus nette = filtre passe-haut\par
4.6.3. Gradient (filtre de Sobel) = calcule le gradient de l'intensit\'e9 de chaque pixel. Ceci indique la direction de la plus forte variation du clair au sombre, ainsi que le taux de changement dans cette direction. \par
\highlight3 4.7. Le photomaton\highlight0\par
Chacune image est obtenue \'e0 partir de la pr\'e9c\'e9dente, en r\'e9duisant la taille de l'image de moiti\'e9, ce qui a donn\'e9 quatre morceaux analogues qu'on a plac\'e9s en carr\'e9 pour obtenir une image ayant la m\'eame taille que l'image d'origine. Le nombre de pixels a \'e9t\'e9 exactement conserv\'e9, on a seulement d\'e9plac\'e9 chacun des pixels (sans en changer la couleur)\par
 au bout de neuf \'e9tapes, l'image original est r\'e9apparue.\par
\highlight3 4.8. St\'e9ganographie\highlight0  = cache les messages dans un support, e.g. images ou texte qui semble anodin.\par
\f2 tatouage \f0\lang4105 = w\f2\lang1033 atermarking \f0\lang4105 =\lang1033 cacher un texte dans une image num\'e9rique invisible \'e0 l'\f2\u339?il nu\f0\lang4105 . \line\f2\lang1033 utilis\f0\'e9e pour prot\'e9ger des images par copyright, et transmettre des messages cach\'e9s. \par
4.8.1 Description d'une image bitmap = un tableau de triplets. \line Chaque triplet = la couleur d'un pixel dans le syst\'e8me RVB\par
4.8.2. Repr\'e9sentation binaire du texte\line Chaque caract\'e8re du texte \'e0 cacher repr\'e9sent\'e9 par son code ASCII \'e9tendu, \'e9crit en base 2\par
4.8.3. Int\'e9gration du texte dans l'image\par
technique de camouflage = dire qu'un nombre pair correspond \'e0 un 0 du texte et qu'un nombre impair correspond \'e0 un 1.\par
si le nombre du tableau de l'image a la parit\'e9 que l'on veut, on le laisse inchang\'e9. \line Si non, on lui ajoute 1 (on soustraira 1 si la valeur de d\'e9part est 255, afin d'\'e9viter les d\'e9bordements).\par
4.8.4. R\'e9cup\'e9ration du texte en cinq \'e9tapes :\par
1. R\'e9cup\'e9rer le tableau d\'e9crivant l'image.\par
2. Remplacer un nombre pair par 0, un nombre impair par 1.\par
3. Grouper les bits par groupes de 8.\par
4. Convertir chaque octet en nombre d\'e9cimal.\par
5. \'c9crire les caract\'e8res correspondant aux codes ASCII obtenus. \par
\highlight2 Chapitre 5 Alg\'e8bre bool\'e9enne et circuits logiques\par
\highlight3 5.1. L'alg\'e8bre de Boole = \highlight0 calcul bool\'e9en = partie des math\'e9matiques qui s'int\'e9resse aux\par
op\'e9rations et aux fonctions sur les variables logiques. \par
B = l'ensemble constitu\'e9 de deux \'e9l\'e9ments appel\'e9s valeurs de v\'e9rit\'e9 \{FAUX, VRAI\}, not\'e9 B = \{0, 1\}.\par
ET: a ET b est VRAI si et seulement si a est VRAI et b est VRAI. \line aussi not\'e9e :\f1  a\f0\'b7b,\f1  a /\\ b\f0\lang4105 , \f1\lang1033  a & b\f0\lang4105 ,\f1\lang1033  a && b\f0\lang4105 ,\f1\lang1033  a AND b \par
OU\f0 : a OU b est VRAI si et seulement si a est VRAI ou b est VRAI, ou si a et b sont VRAIS. \line aussi not\'e9e :\f1  a+b\f0\lang4105 ,\f1\lang1033  a \\/ b\f0\lang4105 , \f1\lang1033 a | b\f0\lang4105 , \f1\lang1033  a || b\f0\lang4105 , \f1\lang1033  a OR b \par
NON\f0\lang4105 : \f1\lang1033 Le contraire de \f0\'ab a \'bb est VRAI si et seulement si a est FAUX.\line ausi notee:\f1  \f3\'d8\f0 a,\f1  ~a\f0\lang4105 ,\f1\lang1033  !a\f0\lang4105 ,\f1\lang1033  NOT a\par
\highlight3\f0\lang4105 5.2. Fonctions logiques et tables de v\'e9rit\'e9\highlight0\par
 table de v\'e9rit\'e9 = tableau qui repr\'e9sente 2+ entr\'e9es et le resula (en colonne) et des \'e9tats binaires\lang1033\par
m\'eames r\'e8gles que les op\'e9rations math\'e9matiques:. La fonction ET (multiplication logique) est prioritaire \'e0 la fonction OU (somme logique).\par
On peut placer des parenth\'e8ses dans les op\'e9rations pour changer la priorit\'e9.\par
propri\'e9t\'e9s: \par
Associativit\'e9 \line (a + b) + c = a + (b + c) = a + b + c\line (a\'b7b)\'b7c = a\'b7(b\'b7c) = a\'b7b\'b7c\par
Commutativit\'e9 = L'ordre est sans importance \line a + b = b + a\line a\'b7b = b\'b7a\par
Distributivit\'e9\line a\'b7(b + c) = a\'b7b + a\'b7c\line comportement diff\'e9rent par rapport aux op\'e9rateurs + et \'b7 habituels :\line a + (b\'b7c) = (a + b)\'b7(a + c)\par
\'c9l\'e9ment neutre\line a + 0 = a\line a\'b71 = a\par
\'c9l\'e9ment nul\line 0\'b7a = 0\line 1 + a = 1\par
Idempotence\line a + a + a + [...] + a = a\line a\'b7a\'b7a\'b7[...]\'b7a = a\par
Compl\'e9mentarit\'e9\line a = \f3\'d8\f0 (\f3\'d8\f0 a)\line a + a = 1\line a \'b7 a = 0\par
Lois de De Morgan\line a\f4\u8901?\f0 b=a+b a+b=a\f4\u8901?\f0 b\par
\highlight3 5\f5 .\f0 3\f5 . \f0 Tables\f5  \f0 de\f5  \f0 Karnaugh\highlight0  = simplifie\f5  \f0 des\f5  \f0\'e9quations\f5  \f0 logiques\f5  \f0 ou\f5  \f0\'e0\f5  \f0 trouve\f5  \f0 l'\'e9quation\f5  \f0 logique\f5  \f0 correspondant\f5  \f0\'e0\f5  \f0 une\f5  \f0 table\f5  \f0 de\f5  \f0 v\'e9rit\'e9\f5 .\f0  m\'e9thode\f5  \f0 graphique\f5 . \f0\par
\f5 5.3.2. M\'e9thode de recherche de l'\'e9quation de la table de v\'e9rit\'e9 = regrouper les valeurs de S \'e9gales \'e0 1 dans des rectangles ayant comme nombre de cases une puissance de 2 \par
\bullet  Les groupes form\'e9s doivent \'eatre les moins nombreux possibles, mais ils doivent englober tous les 1. On peut faire des chevauchements.\par
\bullet  dessiner des rectangles les plus grands possibles.\par
Pour les tables \'e0 4 variables, il faut de pr\'e9f\'e9rence proc\'e9derdans l'ordre suivant :\line 1. les rectangles 8 cases\line 2. les rectangles 4 cases\line 3. les rectangles 2 cases\line 4. les cases uniques.\par
\highlight3 5.4. Circuits logiques\highlight0\par
circuit logique =assemblage de portes logiques pour sch\'e9matiser une expression alg\'e9brique en ex\'e9cutent des op\'e9rations sur des variables logiques (binaires)\par
La porte NAND = la plus simple \'e0 r\'e9aliser du point de vue technologique. possible de r\'e9aliser toutes les fonctions avec\par
\highlight2 Chapitre 6 Programmation et langages\par
\highlight0 programmation = cr\'e9er une s\'e9quence d'instructions pour un ordinateur pour r\'e9soudre un probl\'e8me ou ex\'e9cuter une t\'e2che\par
\highlight3 6.1. La machine de Turing\highlight0\par
machine de Turing = machine th\'e9orique = mod\'e8le id\'e9al de calcul math\'e9matique. utilis\'e9 en informatique th\'e9orique pour r\'e9soudre les probl\'e8mes de complexit\'e9 algorithmique et de calculabilit\'e9.\par
compose\lang1033\'e9 de:\par
\bullet  Un ruban divis\'e9 en cases adjacentes, chaque case contient un symbole parmi un alphabet fini, qui inclue symbole sp\'e9cial \'ab blanc \'bb et autre(s) symbole(s). Le ruban est de longueur infinie \par
\bullet  Une  t\'eate de lecture/\'e9criture = se d\'e9place gauche/droite du ruban.\par
\bullet  Un registre d'\'e9tat = m\'e9morise l'\'e9tat courant de la machine\line\'e9tat de d\'e9part = l'\'e9tat initial de la machine avant son ex\'e9cution\par
\bullet  table d'actions = indique \'e0 la machine quel symbole \'e9crire, comment d\'e9placer la\par
t\'eate de lecture, et le nouvel \'e9tat, en fonction du symbole lu sur le ruban et de l'\'e9tat courant de la machine. Si aucune action n'existe pour une combinaison donn\'e9e d'un symbole lu et d'un \'e9tat courant, la machine s'arr\'eate. \par
machines de Turing = abstraction des ordinateurs :\par
\bullet  Le ruban = la m\'e9moire (centrale et externes) \par
\bullet  La t\'eate de lecture/\'e9criture = le bus \par
\bullet  Le registre d'\'e9tats et la table d'actions = le microprocesseur. \par
\highlight3 6.2. Un peu d'histoire\highlight0\par
1936 = publication de l'article fondateur de la science informatique On Computable Numbers with an Application to the Entscheidungsproblem, par Alan Turing = coup d'envoi \'e0 la cr\'e9ation de l'ordinateur programmable\par
1948 = Konrad Zuse publie un article sur son langage de programmation le Plankalk\'fcl = premier langage de haut niveau.\par
1950s = langages de programmation modernes:\par
\bullet  John Backus, inventeur de Fortran (1954)\par
\bullet  John McCarthy, inventeur de LISP (1958)\par
\bullet  Grace Hopper, surnomm\'e9e \'ab la m\'e8re du langage COBOL \'bb (1959)\par
\bullet  John George Kemeny, concepteur du BASIC (1963)\par
\bullet  Dennis Ritchie et Ken Thompson, inventeurs du langage C (1972)\par
\bullet  Niklaus Wirth inventeur de Pascal (1970) et Modula-2 (1977)\par
\bullet  Bjarne Stroustrup, d\'e9veloppeur de C++ (1985)\par
\bullet  Guido van Rossum, cr\'e9ateur de Python (1991)\par
\bullet  James Gosling et Patrick Naughton, cr\'e9ateurs de Java (1991).\par
Les plus populaires en 2018 sont C, C++, C#, Objective-C, Java, Python, Ruby, Visual Basic, PHP, Javascript, Delphi, SQL, Perl\par
6.2.1. \'c9volution des langages informatiques\par
cinq g\'e9n\'e9rations de langages.\par
premi\'e8re g\'e9n\'e9ration = langage machine = code machine = langage natif = d'instructions et de donn\'e9es \'e0 traiter cod\'e9es en binaire\line e.g.A1 01 10 03 06 01 12 A3 01 14\par
deuxi\'e8me g\'e9n\'e9ration = langage assembleur = code lisible et compr\'e9hensible par les initi\'e9s.\line un par type de processeur. utilis\'e9 pour l'optimisations\line e.g.\line MOV AX, [0110]\line ADD AX, [0112]\line MOV [0114], AX\par
troisi\'e8me g\'e9n\'e9ration =  syntaxe proche de l'anglais. gain \'e9norme en lisibilit\'e9 et en productivit\'e9. Ils ne d\'e9pendent d'un compilateur sp\'e9cifique du processeur. permet la portabilit\'e9 des programmes. beaucoup de langages de programmation actuels sont de troisi\'e8me g\'e9n\'e9ration: Ada, Algol, Basic, Cobol, Eiffel, Fortran, C, C++, Java, Perl, Pascal, Python, Ruby\par
quatri\'e8me g\'e9n\'e9ration = L4G = souvent associ\'e9e \'e0 des bases de donn\'e9esse = int\'e9grant la gestion de l'interface utilisateur et un langage moins technique. chaque con\'e7us pour un travail sp\'e9cifique : gestion de base de donn\'e9es (Microsoft Access, SQL), production graphique (Postscript), cr\'e9ation d'interface (4D).\par
cinqui\'e8me g\'e9n\'e9ration = langages destin\'e9s \'e0 r\'e9soudre des probl\'e8mes \'e0 l'aide de contraintes, et non d'algorithmes \'e9crits. reposent sur la logique. tres utilis\'e9s en intelligence artificielle. e.g. Prolog\par
6.2.2. Quelques langages courants\par
existe environ 2500 langages de programmation\par
C'est dans un memorandum interne de Brian Kernighan, Programming in C : A tutorial, \'e9crit en\par
6.2.3. \'ab Hello world ! \'bb\par
1974 dans les laboratoires Bell = la premi\'e8re version d'un mini-programme affichant \'e0 l'\'e9cran \'ab Hello World! \'bb\par
\highlight3 6.3. Transformation du code source\highlight0\par
Le code source = pas utilisable tel quel = \'e9crit dans un langage de haut niveau \par
deux strat\'e9gies de traduction\par
\bullet  compilation \'e0 la vol\'e9e = l'interpr\'e9tation = Le langage traduit les instructions au fur et \'e0 mesure qu'elles se pr\'e9sentent. \par
\bullet  compilation = Le langage traduire l'ensemble du programme en langage machine, constituant ainsi un deuxi\'e8me programme/fichier. Ensuite il ex\'e9cute ce second programme.\par
6.3.1. Compilation = transformer un langage source en un langage cible. e.g. du code source du programme, en code machine. Une fois compliler l'ex\'e9cutable obtenu peut \'eatre utilis\'e9 sans le code source.\par
6.3.2. Interpr\'e9tation = Chaque ligne de code est compil\'e9e \'ab en temps r\'e9el \'bb par un programme. ce programme interpr\'e8te le code source. e.g. Python\par
6.3.3. Avantages, inconv\'e9nients\par
avantages des langages compil\'e9s = plus rapides \'e0 l'ex\'e9cution \par
pour les langages interpr\'e9t\'e9s l'interpr\'e8te doit \'eatre lanc\'e9 \'e0 chaque ex\'e9cution du programme, ce qui mobilise syst\'e9matiquement les ressources.\par
Les langages interpr\'e9t\'e9s = plus de portabilit\'e9 + facilit\'e9 pour l'\'e9criture du code.\par
 pas de compilation pour tester le code source.\par
\highlight3 6.4. Paradigmes\highlight0\par
paradigme = mod\'e8le qui oriente notre mani\'e8re de penser pour formuler et r\'e9soudre un probl\'e8me.\par
Smalltalk et Java = programmation orient\'e9e objet\line Haskell = programmation fonctionnelle\line C++, Common Lisp, OCaml, Python, Ruby, et Scheme = paradigmes multiples \par
6.4.1. Programmation imp\'e9rative = le paradigme le plus ancien, la majorite des languages = Les op\'e9rations sont d\'e9crites en termes de s\'e9quences d'instructions ex\'e9cut\'e9es par l'ordinateur pour modifier l'\'e9tat du programme.\par
6.4.2. Programmation structur\'e9e = proc\'e9durale = un sous-ensemble de la programmation imp\'e9rative = possible dans n'importe quel langage de programmation proc\'e9dural. evite le GO TO, utilise le Si-Alors-Sinon \par
proc\'e9dure = routine, sous-routine, module ou fonction =  une s\'e9rie d'\'e9tapes \'e0 r\'e9aliser, generalment moin de 50 ligne\par
avantages \'e0 d\'e9couper un programme en proc\'e9dures :\par
\bullet  possibilit\'e9 de r\'e9utiliser le m\'eame code sans le retaper\par
\bullet  il est plus simple de suivre l'\'e9volution du \par
\bullet  on cr\'e9e un code plus modulaire et structur\'e9 \par
\bullet  chaque programmeur peut d\'e9velopper son bout de code de son c\'f4t\'e9\par
6.4.3. Programmation orient\'e9e objet = (POO) = la d\'e9finition et l'assemblage de \'ab briques logicielles \'bb appel\'e9es objets. \par
Un objet = un concept/id\'e9e/entit\'e9 du monde physique\par
langages \'e0 objets  = Ada, Java, C++, C#, Objective C, Eiffel, Python, PHP, Smalltalk,\par
6.4.4. Programmation fonctionnelle = consid\'e8re le calcul en tant qu'\'e9valuation de fonctions math\'e9matiques, et rejette le changement d'\'e9tat et la mutation des donn\'e9es.\par
s'affranchit de fa\'e7on radicale des effets secondaires = interdit toute op\'e9ration d'affectation.\par
utilise un embo\'eetement de \'ab bo\'eetes noires \'bb imbriquable les unes dans les autres. \par
Chaque bo\'eete = param\'e8tre(s) en entr\'e9e et une seule sortie\par
Cette fa\'e7on de penser est tr\'e8s diff\'e9rente de la pens\'e9e habituelle en programmation imp\'e9rative. ne pose g\'e9n\'e9ralement pas de difficult\'e9s particuli\'e8res aux d\'e9butants qui\line n'ont jamais \'e9t\'e9 expos\'e9s \'e0 des langages imp\'e9ratifs. \par
\highlight3 6.5. Pseudo-code\highlight0\par
pseudo-code = fa\'e7on de d\'e9crire un algorithme en respectant certaines conventions, mais sans r\'e9f\'e9rence \'e0 un langage de programmation en particulier. permet de d\'e9velopper une d\'e9marche structur\'e9e, sans souci de la syntaxe rigide d'un langage de programmation.\par
6.5.1. Conventions pas de convention universelle pour le pseudo-code. \par
6.5.2. En pratique\par
\bullet  doit \'eatre suffisamment pr\'e9cis pour que quelqu'un d'autre l'ayant lu sans conna\'eetre l'algorithme soit capable de le coder.\par
\bullet  max 25 lignes.\par
\bullet  faire tenir tout le pseudo-code sur une seule page.\par
\bullet  si ecrit a la main, laisser des lignes blanches r\'e9guli\'e8rement pour pouvoir ajouter \par
\bullet  indentez vers la droite le corps des boucles et des fonctions. \par
\highlight3 6.6. Organigrammes de programmation\par
\highlight0 organigramme = logigramme = algorigramme = ordinogramme = flowchart = forme visuelle d'un algorithme \par
symboles utilis\'e9s:\par
\bullet  ovale = le d\'e9but et la fin du programme.\par
\bullet  parall\'e9logramme = une entr\'e9e (lire une donn\'e9e) ou une sortie (\'e9crire un r\'e9sultat).\par
\bullet  rectangle =modification des variables.\par
\bullet  losange = test conditionnel qui d\'e9bouche surdeux possibilit\'e9s (oui/non).\par
\highlight3 6.7. Les notions principales de la programmation\highlight0\par
dans la plupart des langages de programmation \par
6.7.1. L'affectation = op\'e9ration qui permet d'attribuer une valeur \'e0 une variable\line imaginer un case m\'e9moire appel\'e9e x. \line L'instruction x=t consiste \'e0 remplir la case x avec la valeur de l'expression t. \line Si x contenait d\'e9j\'e0 une valeur, celle-ci est \'e9cras\'e9e.\par
Il ne pas confondre l'affectation avec la comparaison.\line la comparaison x==3 permet de savoir si oui ou non la valeur de la variable x est 3. \par
Incr\'e9mentation / d\'e9cr\'e9mentation = augmenter (ou diminuer) sa valeur d'une ou plusieurs unit\'e9s. on prend la valeur contenue dans x, on y ajoute 1, puis on remet le nouveau r\'e9sultat dans la variable x.\par
e.g. x=x+18\line tellement fr\'e9quente qu'il existe souvent des raccourcis : \line x+=1 (Python)\line x++ (C, Mathematica)\par
6.7.2. Les tests = instruction du genre si\'85 alors\'85 sinon. La suite du programme d\'e9pend du r\'e9sultat du test. On peut encha\'eener des instructions \'ab sinon si \'bb : seule la premi\'e8re dont la condition sera v\'e9rifi\'e9e sera ex\'e9cut\'e9e. une clause sinon qui ne sera que si aucune clause sinon si n'a \'e9t\'e9 v\'e9rifi\'e9e.\par
e.g. python\line if x>=10:\line\tab  x=x-20\line else:\line\tab x=x+2\par
6.7.3. Les boucles = structure de contr\'f4le permettant de r\'e9p\'e9ter une ou un ensemble d'instructions plusieurs fois, tant qu'une condition est satisfaite.\par
Boucle \'ab Tant que \'bb\line TANT QUE Test\line\tab Instruction 1\line FIN TANT QUE\line\tab Instruction 2\par
boucles infinies = boucles qui ne finissent jamais car la condition est toujours satisfaite e.g. on oublie d'incr\'e9menter un compteur. danger\par
Boucles imbriqu\'e9es e.g. les heures et minutes d'une journ\'e9e. premi\'e8re boucle parcourra les heures, la deuxi\'e8me parcourra les minutes, et que l'on incr\'e9mente l'heure seulement quand 60 minutes seront pass\'e9es. \par
Boucle \'ab Jusqu'\'e0 ce que \'bb = ex\'e9cute au moins une fois les instructions comprises \par
Compteur = permet de r\'e9aliser une boucle associ\'e9e \'e0 une variable enti\'e8re qui sera incr\'e9ment\'e9e (ou d\'e9cr\'e9ment\'e9e) \'e0 chaque it\'e9ration.\par
POUR compteur DE 0 A fin\line\tab Instruction 1\line FIN POUR\line\tab Instruction 2\par
It\'e9rateur = objet qui permet une boucle parcourant tous les \'e9l\'e9ments contenus dans une structure de donn\'e9es (e.g.une liste).\par
POUR CHAQUE valeur DANS collection\line\tab Instruction 1\line FIN POUR CHAQUE\line\tab Instruction 2\par
6.7.5. Les sous-programmes = ensemble d'instructions pouvant \'eatre appel\'e9 depuis plusieurs endroits du programme. am\'e9liorer la structure et lisibilit\'e9 du programme . \par
 fonction = effectue une action (par exemple afficher un r\'e9sultat) et/ou retourne une valeur\par
proc\'e9dure =  fonction qui ne renvoie pas de valeur \par
Port\'e9e d'une variable\par
variable locale = variable d\'e9finie dans un sous-programme, est \'ab visible \'bb que dans ce sousprogramme. \par
variable globale = d\'e9finie dans le programme principal ,visible et utilisable partout\par
\highlight2 Chapitre 7 R\'e9cursivit\'e9 et fractales\par
\highlight3 7.1. La r\'e9cursivit\'e9\highlight0\par
it\'e9ration= utilisant une m\'e9thode de r\'e9solution qui est r\'e9p\'e9t\'e9e plusieurs fois, qui est appliqu\'e9e par paliers de fa\'e7on s\'e9quentielle, \par
r\'e9cursivit\'e9 = utilisant une m\'e9thode de r\'e9solution qui est r\'e9p\'e9t\'e9e plusieurs fois qui s'appelle elle-m\'eame.\par
7.1.1. Dans les arts e.g. \b Maurits Cornelis Escher\par
\b0 7.1.2. Vie courante : le format A4\par
format A0 = plus grand format normalis\'e9 (1 m\'e8tre carr\'e9 de surface) se d\'e9cline jusqu'au format A10. \line longueur de A(i) = largeur de A(i-1)\line largeur de A(i) = \'bd longueur de A(i-1)\par
\highlight3 7.2. Fonctions r\'e9cursives et it\'e9ratives\highlight0\par
une fonction qui s'appelle elle-m\'eame = r\'e9cursive.\par
r\'e9cursivit\'e9 crois\'e9e = deux fonctions qui s'appeler l'une l'autre. commune dans la programmation fonctionnelle\par
7.2.1. \'c9l\'e9vation d'un entier x \'e0 une puissance n\par
def puissance(x,n):\par

\pard\li720\sa200\sl276\slmult1  if n==0:\par

\pard\li1440\sa200\sl276\slmult1  return 1\par

\pard\li720\sa200\sl276\slmult1  elif n==1:\par
 \tab return x\par
 elif n%2==0:\par
 \tab return puissance(x*x, n//2)\par
 else:\par
 \tab return puissance(x*x, n//2)*x\par

\pard\sa200\sl276\slmult1 7.2.2. Calcul de la factorielle\par
7.2.3. Coefficients binomiaux\par
La fonction C(n, p) --> le nombre de mani\'e8res de prendre p \'e9l\'e9ments parmi n. \line C(n+1, p+1) = C(n, p) + C(n, p+1) (formule de Pascal)\par
def C(n,p):\line\tab if (n>p) and (p>0):\line\tab\tab return C(n-1,p-1)+C(n-1,p)\line\tab else:\line\tab\tab return 1\par
\highlight3 7.3. Les dangers de la r\'e9cursivit\'e9\par
\highlight0 appeler le programme multiple fois pour calculer ce qui a deja eter calculer --> pas efficace \par
\f6 algorithmes r\f5\'e9cursifs n\'e9cessite souvent une pile (stack), peux etre difficile a implementer\par
arguments en faveur de la pr\'e9sentation r\'e9cursive :\par
\bullet  permet de pr\'e9senter simplement des algorithmes plus astucieux et efficaces\par
\bullet  Les compilateurs d'aujourd'hui peuvent mettre en \f6\u339?uvre leurs\f5\lang4105  \f6\lang1033 optimisations et aboutir \f5\'e0 des codes objets efficaces.\par
\bullet  Des structures de donn\'e9es r\'e9cursives ont \'e9t\'e9 con\'e7ues pour leur efficacit\'e9, mais innutile pour les algorithmes non r\'e9cursifs.\par
compilateur = programme qui transforme un code source \'e9crit dans un langage de programmation (le langage source) en un autre langage informatique (le langage cible).\par
\highlight3 7.4. Les tours de Hano\'ef\highlight0\par
les tours de Hano\'ef = jeu de r\'e9flexion. but = d\'e9placer des disques de diam\'e8tres diff\'e9rents d'une tour de \'ab d\'e9part \'bb \'e0 une tour d' \'ab arriv\'e9e \'bb (avec une tour \'ab interm\'e9diaire \'bb), en un minimum de coups\line les r\'e8gles:\line\bullet  on peut d\'e9placer que un disque \'e0 la fois\line\bullet  on peut placer un disque sur un autre disque plus grand ou sur un emplacement vide\par
jeu \'e0 64 disques = minimum de 2^64 -1 = \b 18,446,744,073,709,551,616\b0  d\'e9placements\par
d\'e9placer n disques de A vers C en passant par B consiste \'e0 :\par
 \tab 1. d\'e9placer (n-1) disques de A vers B (en passant par C);\par
\tab  2. d\'e9placer le plus grand disque de A vers C ;\par
 \tab 3. d\'e9placer (n-1) disques de B vers C (en passant par A). \par
7.4.2. R\'e9solution it\'e9rative\par
effectuer successivement les deux d\'e9placements suivants, iterativement :\line\bullet  d\'e9placer le plus petit disque d'un emplacement \'e0 l'emplacement suivant (de A vers B, de B vers C, ou de C vers A)\line\bullet  d\'e9placer un autre disque\par
7.4.3. Hano\'ef, Pascal et Sierpinski\par
Si l'on repr\'e9sente sur un graphique tous les mouvements possibles des tours de Hano\'ef, on obtient une figure fractale. Ce triangle ressemble \'e0 deux autres triangles c\'e9l\'e8bres : le triangle de Pascal et  de Sierpinski \par
\highlight3 7.5. Le compte est bon\highlight0\par
ans\par
\par
\par
\par
\f0\par
chattons\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
}
 